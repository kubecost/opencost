////////////////////////////////////////////////////////////////////////////////
//
//                             DO NOT MODIFY
//
//                          ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
//
//
//            This source file was automatically generated by bingen.
//
////////////////////////////////////////////////////////////////////////////////

package kubecost

import (
	"encoding"
	"fmt"
	"reflect"
	"strings"
	"time"

	util "github.com/kubecost/cost-model/pkg/util"
)

const (
	// GeneratorPackageName is the package the generator is targetting
	GeneratorPackageName string = "kubecost"

	// CodecVersion is the version passed into the generator
	CodecVersion uint8 = 15
)

//--------------------------------------------------------------------------
//  Type Map
//--------------------------------------------------------------------------

// Generated type map for resolving interface implementations to
// to concrete types
var typeMap map[string]reflect.Type = map[string]reflect.Type{
	"Allocation":            reflect.TypeOf((*Allocation)(nil)).Elem(),
	"AllocationProperties":  reflect.TypeOf((*AllocationProperties)(nil)).Elem(),
	"AllocationSet":         reflect.TypeOf((*AllocationSet)(nil)).Elem(),
	"AllocationSetRange":    reflect.TypeOf((*AllocationSetRange)(nil)).Elem(),
	"Any":                   reflect.TypeOf((*Any)(nil)).Elem(),
	"AssetProperties":       reflect.TypeOf((*AssetProperties)(nil)).Elem(),
	"AssetSet":              reflect.TypeOf((*AssetSet)(nil)).Elem(),
	"AssetSetRange":         reflect.TypeOf((*AssetSetRange)(nil)).Elem(),
	"Breakdown":             reflect.TypeOf((*Breakdown)(nil)).Elem(),
	"Cloud":                 reflect.TypeOf((*Cloud)(nil)).Elem(),
	"ClusterManagement":     reflect.TypeOf((*ClusterManagement)(nil)).Elem(),
	"Disk":                  reflect.TypeOf((*Disk)(nil)).Elem(),
	"LoadBalancer":          reflect.TypeOf((*LoadBalancer)(nil)).Elem(),
	"Network":               reflect.TypeOf((*Network)(nil)).Elem(),
	"Node":                  reflect.TypeOf((*Node)(nil)).Elem(),
	"PVAllocation":          reflect.TypeOf((*PVAllocation)(nil)).Elem(),
	"PVKey":                 reflect.TypeOf((*PVKey)(nil)).Elem(),
	"RawAllocationOnlyData": reflect.TypeOf((*RawAllocationOnlyData)(nil)).Elem(),
	"SharedAsset":           reflect.TypeOf((*SharedAsset)(nil)).Elem(),
	"Window":                reflect.TypeOf((*Window)(nil)).Elem(),
}

//--------------------------------------------------------------------------
//  Type Helpers
//--------------------------------------------------------------------------

// typeToString determines the basic properties of the type, the qualifier, package path, and
// type name, and returns the qualified type
func typeToString(f interface{}) string {
	qual := ""
	t := reflect.TypeOf(f)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		qual = "*"
	}

	return fmt.Sprintf("%s%s.%s", qual, t.PkgPath(), t.Name())
}

// resolveType uses the name of a type and returns the package, base type name, and whether
// or not it's a pointer.
func resolveType(t string) (pkg string, name string, isPtr bool) {
	isPtr = t[:1] == "*"
	if isPtr {
		t = t[1:]
	}

	slashIndex := strings.LastIndex(t, "/")
	if slashIndex >= 0 {
		t = t[slashIndex+1:]
	}
	parts := strings.Split(t, ".")
	if parts[0] == GeneratorPackageName {
		parts[0] = ""
	}

	pkg = parts[0]
	name = parts[1]
	return
}

//--------------------------------------------------------------------------
//  Allocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Allocation instance
// into a byte array
func (target *Allocation) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteString(target.Name) // write string
	if target.Properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AllocationProperties) ---
		a, errA := target.Properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AllocationProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	b, errB := target.Window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.Start.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	d, errD := target.End.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	buff.WriteFloat64(target.CPUCoreHours)               // write float64
	buff.WriteFloat64(target.CPUCoreRequestAverage)      // write float64
	buff.WriteFloat64(target.CPUCoreUsageAverage)        // write float64
	buff.WriteFloat64(target.CPUCost)                    // write float64
	buff.WriteFloat64(target.CPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.GPUHours)                   // write float64
	buff.WriteFloat64(target.GPUCost)                    // write float64
	buff.WriteFloat64(target.GPUCostAdjustment)          // write float64
	buff.WriteFloat64(target.NetworkTransferBytes)       // write float64
	buff.WriteFloat64(target.NetworkReceiveBytes)        // write float64
	buff.WriteFloat64(target.NetworkCost)                // write float64
	buff.WriteFloat64(target.NetworkCostAdjustment)      // write float64
	buff.WriteFloat64(target.LoadBalancerCost)           // write float64
	buff.WriteFloat64(target.LoadBalancerCostAdjustment) // write float64
	// --- [begin][write][alias](PVAllocations) ---
	if map[PVKey]*PVAllocation(target.PVs) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[PVKey]*PVAllocation) ---
		buff.WriteInt(len(map[PVKey]*PVAllocation(target.PVs))) // map length
		for v, z := range map[PVKey]*PVAllocation(target.PVs) {
			// --- [begin][write][struct](PVKey) ---
			e, errE := v.MarshalBinary()
			if errE != nil {
				return nil, errE
			}
			buff.WriteInt(len(e))
			buff.WriteBytes(e)
			// --- [end][write][struct](PVKey) ---

			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](PVAllocation) ---
				f, errF := z.MarshalBinary()
				if errF != nil {
					return nil, errF
				}
				buff.WriteInt(len(f))
				buff.WriteBytes(f)
				// --- [end][write][struct](PVAllocation) ---

			}
		}
		// --- [end][write][map](map[PVKey]*PVAllocation) ---

	}
	// --- [end][write][alias](PVAllocations) ---

	buff.WriteFloat64(target.PVCostAdjustment)       // write float64
	buff.WriteFloat64(target.RAMByteHours)           // write float64
	buff.WriteFloat64(target.RAMBytesRequestAverage) // write float64
	buff.WriteFloat64(target.RAMBytesUsageAverage)   // write float64
	buff.WriteFloat64(target.RAMCost)                // write float64
	buff.WriteFloat64(target.RAMCostAdjustment)      // write float64
	buff.WriteFloat64(target.SharedCost)             // write float64
	buff.WriteFloat64(target.ExternalCost)           // write float64
	if target.RawAllocationOnly == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](RawAllocationOnlyData) ---
		g, errG := target.RawAllocationOnly.MarshalBinary()
		if errG != nil {
			return nil, errG
		}
		buff.WriteInt(len(g))
		buff.WriteBytes(g)
		// --- [end][write][struct](RawAllocationOnlyData) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Allocation type
func (target *Allocation) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Allocation. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadString() // read string
	target.Name = a

	if buff.ReadUInt8() == uint8(0) {
		target.Properties = nil
	} else {
		// --- [begin][read][struct](AllocationProperties) ---
		b := &AllocationProperties{}
		c := buff.ReadInt()    // byte array length
		d := buff.ReadBytes(c) // byte array
		errA := b.UnmarshalBinary(d)
		if errA != nil {
			return errA
		}
		target.Properties = b
		// --- [end][read][struct](AllocationProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	e := &Window{}
	f := buff.ReadInt()    // byte array length
	g := buff.ReadBytes(f) // byte array
	errB := e.UnmarshalBinary(g)
	if errB != nil {
		return errB
	}
	target.Window = *e
	// --- [end][read][struct](Window) ---

	// --- [begin][read][reference](time.Time) ---
	h := &time.Time{}
	k := buff.ReadInt()    // byte array length
	l := buff.ReadBytes(k) // byte array
	errC := h.UnmarshalBinary(l)
	if errC != nil {
		return errC
	}
	target.Start = *h
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	m := &time.Time{}
	n := buff.ReadInt()    // byte array length
	o := buff.ReadBytes(n) // byte array
	errD := m.UnmarshalBinary(o)
	if errD != nil {
		return errD
	}
	target.End = *m
	// --- [end][read][reference](time.Time) ---

	p := buff.ReadFloat64() // read float64
	target.CPUCoreHours = p

	q := buff.ReadFloat64() // read float64
	target.CPUCoreRequestAverage = q

	r := buff.ReadFloat64() // read float64
	target.CPUCoreUsageAverage = r

	s := buff.ReadFloat64() // read float64
	target.CPUCost = s

	t := buff.ReadFloat64() // read float64
	target.CPUCostAdjustment = t

	u := buff.ReadFloat64() // read float64
	target.GPUHours = u

	w := buff.ReadFloat64() // read float64
	target.GPUCost = w

	x := buff.ReadFloat64() // read float64
	target.GPUCostAdjustment = x

	y := buff.ReadFloat64() // read float64
	target.NetworkTransferBytes = y

	aa := buff.ReadFloat64() // read float64
	target.NetworkReceiveBytes = aa

	bb := buff.ReadFloat64() // read float64
	target.NetworkCost = bb

	cc := buff.ReadFloat64() // read float64
	target.NetworkCostAdjustment = cc

	dd := buff.ReadFloat64() // read float64
	target.LoadBalancerCost = dd

	ee := buff.ReadFloat64() // read float64
	target.LoadBalancerCostAdjustment = ee

	// --- [begin][read][alias](PVAllocations) ---
	var ff map[PVKey]*PVAllocation
	if buff.ReadUInt8() == uint8(0) {
		ff = nil
	} else {
		// --- [begin][read][map](map[PVKey]*PVAllocation) ---
		hh := buff.ReadInt() // map len
		gg := make(map[PVKey]*PVAllocation, hh)
		for i := 0; i < hh; i++ {
			// --- [begin][read][struct](PVKey) ---
			kk := &PVKey{}
			ll := buff.ReadInt()     // byte array length
			mm := buff.ReadBytes(ll) // byte array
			errE := kk.UnmarshalBinary(mm)
			if errE != nil {
				return errE
			}
			v := *kk
			// --- [end][read][struct](PVKey) ---

			var z *PVAllocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](PVAllocation) ---
				nn := &PVAllocation{}
				oo := buff.ReadInt()     // byte array length
				pp := buff.ReadBytes(oo) // byte array
				errF := nn.UnmarshalBinary(pp)
				if errF != nil {
					return errF
				}
				z = nn
				// --- [end][read][struct](PVAllocation) ---

			}
			gg[v] = z
		}
		ff = gg
		// --- [end][read][map](map[PVKey]*PVAllocation) ---

	}
	target.PVs = PVAllocations(ff)
	// --- [end][read][alias](PVAllocations) ---

	qq := buff.ReadFloat64() // read float64
	target.PVCostAdjustment = qq

	rr := buff.ReadFloat64() // read float64
	target.RAMByteHours = rr

	ss := buff.ReadFloat64() // read float64
	target.RAMBytesRequestAverage = ss

	tt := buff.ReadFloat64() // read float64
	target.RAMBytesUsageAverage = tt

	uu := buff.ReadFloat64() // read float64
	target.RAMCost = uu

	ww := buff.ReadFloat64() // read float64
	target.RAMCostAdjustment = ww

	xx := buff.ReadFloat64() // read float64
	target.SharedCost = xx

	yy := buff.ReadFloat64() // read float64
	target.ExternalCost = yy

	if buff.ReadUInt8() == uint8(0) {
		target.RawAllocationOnly = nil
	} else {
		// --- [begin][read][struct](RawAllocationOnlyData) ---
		aaa := &RawAllocationOnlyData{}
		bbb := buff.ReadInt()      // byte array length
		ccc := buff.ReadBytes(bbb) // byte array
		errG := aaa.UnmarshalBinary(ccc)
		if errG != nil {
			return errG
		}
		target.RawAllocationOnly = aaa
		// --- [end][read][struct](RawAllocationOnlyData) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationProperties instance
// into a byte array
func (target *AllocationProperties) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteString(target.Cluster)        // write string
	buff.WriteString(target.Node)           // write string
	buff.WriteString(target.Container)      // write string
	buff.WriteString(target.Controller)     // write string
	buff.WriteString(target.ControllerKind) // write string
	buff.WriteString(target.Namespace)      // write string
	buff.WriteString(target.Pod)            // write string
	if target.Services == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Services)) // array length
		for i := 0; i < len(target.Services); i++ {
			buff.WriteString(target.Services[i]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	buff.WriteString(target.ProviderID) // write string
	// --- [begin][write][alias](AllocationLabels) ---
	if map[string]string(target.Labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Labels))) // map length
		for v, z := range map[string]string(target.Labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationLabels) ---

	// --- [begin][write][alias](AllocationAnnotations) ---
	if map[string]string(target.Annotations) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.Annotations))) // map length
		for vv, zz := range map[string]string(target.Annotations) {
			buff.WriteString(vv) // write string
			buff.WriteString(zz) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AllocationAnnotations) ---

	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationProperties type
func (target *AllocationProperties) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationProperties. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadString() // read string
	target.Cluster = a

	b := buff.ReadString() // read string
	target.Node = b

	c := buff.ReadString() // read string
	target.Container = c

	d := buff.ReadString() // read string
	target.Controller = d

	e := buff.ReadString() // read string
	target.ControllerKind = e

	f := buff.ReadString() // read string
	target.Namespace = f

	g := buff.ReadString() // read string
	target.Pod = g

	if buff.ReadUInt8() == uint8(0) {
		target.Services = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		k := buff.ReadInt() // array len
		h := make([]string, k)
		for i := 0; i < k; i++ {
			var l string
			m := buff.ReadString() // read string
			l = m

			h[i] = l
		}
		target.Services = h
		// --- [end][read][slice]([]string) ---

	}
	n := buff.ReadString() // read string
	target.ProviderID = n

	// --- [begin][read][alias](AllocationLabels) ---
	var o map[string]string
	if buff.ReadUInt8() == uint8(0) {
		o = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		q := buff.ReadInt() // map len
		p := make(map[string]string, q)
		for j := 0; j < q; j++ {
			var v string
			r := buff.ReadString() // read string
			v = r

			var z string
			s := buff.ReadString() // read string
			z = s

			p[v] = z
		}
		o = p
		// --- [end][read][map](map[string]string) ---

	}
	target.Labels = AllocationLabels(o)
	// --- [end][read][alias](AllocationLabels) ---

	// --- [begin][read][alias](AllocationAnnotations) ---
	var t map[string]string
	if buff.ReadUInt8() == uint8(0) {
		t = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		w := buff.ReadInt() // map len
		u := make(map[string]string, w)
		for ii := 0; ii < w; ii++ {
			var vv string
			x := buff.ReadString() // read string
			vv = x

			var zz string
			y := buff.ReadString() // read string
			zz = y

			u[vv] = zz
		}
		t = u
		// --- [end][read][map](map[string]string) ---

	}
	target.Annotations = AllocationAnnotations(t)
	// --- [end][read][alias](AllocationAnnotations) ---

	return nil
}

//--------------------------------------------------------------------------
//  AllocationSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSet instance
// into a byte array
func (target *AllocationSet) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Allocation) ---
		buff.WriteInt(len(target.allocations)) // map length
		for v, z := range target.allocations {
			buff.WriteString(v) // write string
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Allocation) ---
				a, errA := z.MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](Allocation) ---

			}
		}
		// --- [end][write][map](map[string]*Allocation) ---

	}
	if target.externalKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.externalKeys)) // map length
		for vv, zz := range target.externalKeys {
			buff.WriteString(vv) // write string
			buff.WriteBool(zz)   // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	if target.idleKeys == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]bool) ---
		buff.WriteInt(len(target.idleKeys)) // map length
		for vvv, zzz := range target.idleKeys {
			buff.WriteString(vvv) // write string
			buff.WriteBool(zzz)   // write bool
		}
		// --- [end][write][map](map[string]bool) ---

	}
	buff.WriteString(target.FromSource) // write string
	// --- [begin][write][struct](Window) ---
	b, errB := target.Window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for i := 0; i < len(target.Warnings); i++ {
			buff.WriteString(target.Warnings[i]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for j := 0; j < len(target.Errors); j++ {
			buff.WriteString(target.Errors[j]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSet type
func (target *AllocationSet) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSet. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.allocations = nil
	} else {
		// --- [begin][read][map](map[string]*Allocation) ---
		b := buff.ReadInt() // map len
		a := make(map[string]*Allocation, b)
		for i := 0; i < b; i++ {
			var v string
			c := buff.ReadString() // read string
			v = c

			var z *Allocation
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][struct](Allocation) ---
				d := &Allocation{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				z = d
				// --- [end][read][struct](Allocation) ---

			}
			a[v] = z
		}
		target.allocations = a
		// --- [end][read][map](map[string]*Allocation) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.externalKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		h := buff.ReadInt() // map len
		g := make(map[string]bool, h)
		for j := 0; j < h; j++ {
			var vv string
			k := buff.ReadString() // read string
			vv = k

			var zz bool
			l := buff.ReadBool() // read bool
			zz = l

			g[vv] = zz
		}
		target.externalKeys = g
		// --- [end][read][map](map[string]bool) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.idleKeys = nil
	} else {
		// --- [begin][read][map](map[string]bool) ---
		n := buff.ReadInt() // map len
		m := make(map[string]bool, n)
		for ii := 0; ii < n; ii++ {
			var vvv string
			o := buff.ReadString() // read string
			vvv = o

			var zzz bool
			p := buff.ReadBool() // read bool
			zzz = p

			m[vvv] = zzz
		}
		target.idleKeys = m
		// --- [end][read][map](map[string]bool) ---

	}
	q := buff.ReadString() // read string
	target.FromSource = q

	// --- [begin][read][struct](Window) ---
	r := &Window{}
	s := buff.ReadInt()    // byte array length
	t := buff.ReadBytes(s) // byte array
	errB := r.UnmarshalBinary(t)
	if errB != nil {
		return errB
	}
	target.Window = *r
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		w := buff.ReadInt() // array len
		u := make([]string, w)
		for jj := 0; jj < w; jj++ {
			var x string
			y := buff.ReadString() // read string
			x = y

			u[jj] = x
		}
		target.Warnings = u
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		bb := buff.ReadInt() // array len
		aa := make([]string, bb)
		for iii := 0; iii < bb; iii++ {
			var cc string
			dd := buff.ReadString() // read string
			cc = dd

			aa[iii] = cc
		}
		target.Errors = aa
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AllocationSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AllocationSetRange instance
// into a byte array
func (target *AllocationSetRange) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.allocations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AllocationSet) ---
		buff.WriteInt(len(target.allocations)) // array length
		for i := 0; i < len(target.allocations); i++ {
			if target.allocations[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AllocationSet) ---
				a, errA := target.allocations[i].MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](AllocationSet) ---

			}
		}
		// --- [end][write][slice]([]*AllocationSet) ---

	}
	buff.WriteString(target.FromStore) // write string
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AllocationSetRange type
func (target *AllocationSetRange) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AllocationSetRange. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.allocations = nil
	} else {
		// --- [begin][read][slice]([]*AllocationSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AllocationSet, b)
		for i := 0; i < b; i++ {
			var c *AllocationSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AllocationSet) ---
				d := &AllocationSet{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AllocationSet) ---

			}
			a[i] = c
		}
		target.allocations = a
		// --- [end][read][slice]([]*AllocationSet) ---

	}
	g := buff.ReadString() // read string
	target.FromStore = g

	return nil
}

//--------------------------------------------------------------------------
//  Any
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Any instance
// into a byte array
func (target *Any) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Any type
func (target *Any) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Any. Expected %d, got %d", CodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			d := buff.ReadString() // read string
			v = d

			var z string
			e := buff.ReadString() // read string
			z = e

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  AssetProperties
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetProperties instance
// into a byte array
func (target *AssetProperties) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteString(target.Category)   // write string
	buff.WriteString(target.Provider)   // write string
	buff.WriteString(target.Account)    // write string
	buff.WriteString(target.Project)    // write string
	buff.WriteString(target.Service)    // write string
	buff.WriteString(target.Cluster)    // write string
	buff.WriteString(target.Name)       // write string
	buff.WriteString(target.ProviderID) // write string
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetProperties type
func (target *AssetProperties) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetProperties. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadString() // read string
	target.Category = a

	b := buff.ReadString() // read string
	target.Provider = b

	c := buff.ReadString() // read string
	target.Account = c

	d := buff.ReadString() // read string
	target.Project = d

	e := buff.ReadString() // read string
	target.Service = e

	f := buff.ReadString() // read string
	target.Cluster = f

	g := buff.ReadString() // read string
	target.Name = g

	h := buff.ReadString() // read string
	target.ProviderID = h

	return nil
}

//--------------------------------------------------------------------------
//  AssetSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSet instance
// into a byte array
func (target *AssetSet) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.aggregateBy == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.aggregateBy)) // array length
		for i := 0; i < len(target.aggregateBy); i++ {
			buff.WriteString(target.aggregateBy[i]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]Asset) ---
		buff.WriteInt(len(target.assets)) // map length
		for v, z := range target.assets {
			buff.WriteString(v) // write string
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][interface](Asset) ---
				a := reflect.ValueOf(z).Interface()
				b, okA := a.(encoding.BinaryMarshaler)
				if !okA {
					return nil, fmt.Errorf("Type: %s does not implement encoding.BinaryMarshaler", typeToString(z))
				}
				c, errA := b.MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteString(typeToString(z))
				buff.WriteInt(len(c))
				buff.WriteBytes(c)
				// --- [end][write][interface](Asset) ---

			}
		}
		// --- [end][write][map](map[string]Asset) ---

	}
	buff.WriteString(target.FromSource) // write string
	// --- [begin][write][struct](Window) ---
	d, errB := target.Window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	if target.Warnings == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Warnings)) // array length
		for j := 0; j < len(target.Warnings); j++ {
			buff.WriteString(target.Warnings[j]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	if target.Errors == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]string) ---
		buff.WriteInt(len(target.Errors)) // array length
		for ii := 0; ii < len(target.Errors); ii++ {
			buff.WriteString(target.Errors[ii]) // write string
		}
		// --- [end][write][slice]([]string) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSet type
func (target *AssetSet) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSet. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.aggregateBy = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		b := buff.ReadInt() // array len
		a := make([]string, b)
		for i := 0; i < b; i++ {
			var c string
			d := buff.ReadString() // read string
			c = d

			a[i] = c
		}
		target.aggregateBy = a
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.assets = nil
	} else {
		// --- [begin][read][map](map[string]Asset) ---
		f := buff.ReadInt() // map len
		e := make(map[string]Asset, f)
		for j := 0; j < f; j++ {
			var v string
			g := buff.ReadString() // read string
			v = g

			var z Asset
			if buff.ReadUInt8() == uint8(0) {
				z = nil
			} else {
				// --- [begin][read][interface](Asset) ---
				h := buff.ReadString()
				_, k, _ := resolveType(h)
				if _, ok := typeMap[k]; !ok {
					return fmt.Errorf("Unknown Type: %s", k)
				}
				l, okA := reflect.New(typeMap[k]).Interface().(interface{ UnmarshalBinary([]byte) error })
				if !okA {
					return fmt.Errorf("Type: %s does not implement UnmarshalBinary([]byte) error", k)
				}
				m := buff.ReadInt()    // byte array length
				n := buff.ReadBytes(m) // byte array
				errA := l.UnmarshalBinary(n)
				if errA != nil {
					return errA
				}
				z = l.(Asset)
				// --- [end][read][interface](Asset) ---

			}
			e[v] = z
		}
		target.assets = e
		// --- [end][read][map](map[string]Asset) ---

	}
	o := buff.ReadString() // read string
	target.FromSource = o

	// --- [begin][read][struct](Window) ---
	p := &Window{}
	q := buff.ReadInt()    // byte array length
	r := buff.ReadBytes(q) // byte array
	errB := p.UnmarshalBinary(r)
	if errB != nil {
		return errB
	}
	target.Window = *p
	// --- [end][read][struct](Window) ---

	if buff.ReadUInt8() == uint8(0) {
		target.Warnings = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		t := buff.ReadInt() // array len
		s := make([]string, t)
		for ii := 0; ii < t; ii++ {
			var u string
			w := buff.ReadString() // read string
			u = w

			s[ii] = u
		}
		target.Warnings = s
		// --- [end][read][slice]([]string) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.Errors = nil
	} else {
		// --- [begin][read][slice]([]string) ---
		y := buff.ReadInt() // array len
		x := make([]string, y)
		for jj := 0; jj < y; jj++ {
			var aa string
			bb := buff.ReadString() // read string
			aa = bb

			x[jj] = aa
		}
		target.Errors = x
		// --- [end][read][slice]([]string) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  AssetSetRange
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this AssetSetRange instance
// into a byte array
func (target *AssetSetRange) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.assets == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]*AssetSet) ---
		buff.WriteInt(len(target.assets)) // array length
		for i := 0; i < len(target.assets); i++ {
			if target.assets[i] == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](AssetSet) ---
				a, errA := target.assets[i].MarshalBinary()
				if errA != nil {
					return nil, errA
				}
				buff.WriteInt(len(a))
				buff.WriteBytes(a)
				// --- [end][write][struct](AssetSet) ---

			}
		}
		// --- [end][write][slice]([]*AssetSet) ---

	}
	buff.WriteString(target.FromStore) // write string
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the AssetSetRange type
func (target *AssetSetRange) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling AssetSetRange. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.assets = nil
	} else {
		// --- [begin][read][slice]([]*AssetSet) ---
		b := buff.ReadInt() // array len
		a := make([]*AssetSet, b)
		for i := 0; i < b; i++ {
			var c *AssetSet
			if buff.ReadUInt8() == uint8(0) {
				c = nil
			} else {
				// --- [begin][read][struct](AssetSet) ---
				d := &AssetSet{}
				e := buff.ReadInt()    // byte array length
				f := buff.ReadBytes(e) // byte array
				errA := d.UnmarshalBinary(f)
				if errA != nil {
					return errA
				}
				c = d
				// --- [end][read][struct](AssetSet) ---

			}
			a[i] = c
		}
		target.assets = a
		// --- [end][read][slice]([]*AssetSet) ---

	}
	g := buff.ReadString() // read string
	target.FromStore = g

	return nil
}

//--------------------------------------------------------------------------
//  Breakdown
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Breakdown instance
// into a byte array
func (target *Breakdown) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteFloat64(target.Idle)   // write float64
	buff.WriteFloat64(target.Other)  // write float64
	buff.WriteFloat64(target.System) // write float64
	buff.WriteFloat64(target.User)   // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Breakdown type
func (target *Breakdown) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Breakdown. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.Idle = a

	b := buff.ReadFloat64() // read float64
	target.Other = b

	c := buff.ReadFloat64() // read float64
	target.System = c

	d := buff.ReadFloat64() // read float64
	target.User = d

	return nil
}

//--------------------------------------------------------------------------
//  Cloud
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Cloud instance
// into a byte array
func (target *Cloud) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.Credit)     // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Cloud type
func (target *Cloud) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Cloud. Expected %d, got %d", CodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			d := buff.ReadString() // read string
			v = d

			var z string
			e := buff.ReadString() // read string
			z = e

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.Credit = w

	return nil
}

//--------------------------------------------------------------------------
//  ClusterManagement
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ClusterManagement instance
// into a byte array
func (target *ClusterManagement) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][struct](Window) ---
	b, errB := target.window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ClusterManagement type
func (target *ClusterManagement) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ClusterManagement. Expected %d, got %d", CodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			d := buff.ReadString() // read string
			v = d

			var z string
			e := buff.ReadString() // read string
			z = e

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][struct](Window) ---
	k := &Window{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.window = *k
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	return nil
}

//--------------------------------------------------------------------------
//  Disk
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Disk instance
// into a byte array
func (target *Disk) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	buff.WriteFloat64(target.ByteHours)  // write float64
	buff.WriteFloat64(target.Local)      // write float64
	if target.Breakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		e, errE := target.Breakdown.MarshalBinary()
		if errE != nil {
			return nil, errE
		}
		buff.WriteInt(len(e))
		buff.WriteBytes(e)
		// --- [end][write][struct](Breakdown) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Disk type
func (target *Disk) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Disk. Expected %d, got %d", CodecVersion, version)
	}

	// --- [begin][read][alias](AssetLabels) ---
	var a map[string]string
	if buff.ReadUInt8() == uint8(0) {
		a = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		c := buff.ReadInt() // map len
		b := make(map[string]string, c)
		for i := 0; i < c; i++ {
			var v string
			d := buff.ReadString() // read string
			v = d

			var z string
			e := buff.ReadString() // read string
			z = e

			b[v] = z
		}
		a = b
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(a)
	// --- [end][read][alias](AssetLabels) ---

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		f := &AssetProperties{}
		g := buff.ReadInt()    // byte array length
		h := buff.ReadBytes(g) // byte array
		errA := f.UnmarshalBinary(h)
		if errA != nil {
			return errA
		}
		target.properties = f
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	w := buff.ReadFloat64() // read float64
	target.ByteHours = w

	x := buff.ReadFloat64() // read float64
	target.Local = x

	if buff.ReadUInt8() == uint8(0) {
		target.Breakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		y := &Breakdown{}
		aa := buff.ReadInt()     // byte array length
		bb := buff.ReadBytes(aa) // byte array
		errE := y.UnmarshalBinary(bb)
		if errE != nil {
			return errE
		}
		target.Breakdown = y
		// --- [end][read][struct](Breakdown) ---

	}
	return nil
}

//--------------------------------------------------------------------------
//  LoadBalancer
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this LoadBalancer instance
// into a byte array
func (target *LoadBalancer) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the LoadBalancer type
func (target *LoadBalancer) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling LoadBalancer. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		f := buff.ReadInt() // map len
		e := make(map[string]string, f)
		for i := 0; i < f; i++ {
			var v string
			g := buff.ReadString() // read string
			v = g

			var z string
			h := buff.ReadString() // read string
			z = h

			e[v] = z
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  Network
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Network instance
// into a byte array
func (target *Network) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment) // write float64
	buff.WriteFloat64(target.Cost)       // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Network type
func (target *Network) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Network. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		f := buff.ReadInt() // map len
		e := make(map[string]string, f)
		for i := 0; i < f; i++ {
			var v string
			g := buff.ReadString() // read string
			v = g

			var z string
			h := buff.ReadString() // read string
			z = h

			e[v] = z
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadFloat64() // read float64
	target.Cost = u

	return nil
}

//--------------------------------------------------------------------------
//  Node
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Node instance
// into a byte array
func (target *Node) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.start.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	c, errC := target.end.MarshalBinary()
	if errC != nil {
		return nil, errC
	}
	buff.WriteInt(len(c))
	buff.WriteBytes(c)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][struct](Window) ---
	d, errD := target.window.MarshalBinary()
	if errD != nil {
		return nil, errD
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.adjustment)   // write float64
	buff.WriteString(target.NodeType)      // write string
	buff.WriteFloat64(target.CPUCoreHours) // write float64
	buff.WriteFloat64(target.RAMByteHours) // write float64
	buff.WriteFloat64(target.GPUHours)     // write float64
	if target.CPUBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		e, errE := target.CPUBreakdown.MarshalBinary()
		if errE != nil {
			return nil, errE
		}
		buff.WriteInt(len(e))
		buff.WriteBytes(e)
		// --- [end][write][struct](Breakdown) ---

	}
	if target.RAMBreakdown == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Breakdown) ---
		f, errF := target.RAMBreakdown.MarshalBinary()
		if errF != nil {
			return nil, errF
		}
		buff.WriteInt(len(f))
		buff.WriteBytes(f)
		// --- [end][write][struct](Breakdown) ---

	}
	buff.WriteFloat64(target.CPUCost)     // write float64
	buff.WriteFloat64(target.GPUCost)     // write float64
	buff.WriteFloat64(target.GPUCount)    // write float64
	buff.WriteFloat64(target.RAMCost)     // write float64
	buff.WriteFloat64(target.Discount)    // write float64
	buff.WriteFloat64(target.Preemptible) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Node type
func (target *Node) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Node. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		f := buff.ReadInt() // map len
		e := make(map[string]string, f)
		for i := 0; i < f; i++ {
			var v string
			g := buff.ReadString() // read string
			v = g

			var z string
			h := buff.ReadString() // read string
			z = h

			e[v] = z
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][reference](time.Time) ---
	k := &time.Time{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.start = *k
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][reference](time.Time) ---
	n := &time.Time{}
	o := buff.ReadInt()    // byte array length
	p := buff.ReadBytes(o) // byte array
	errC := n.UnmarshalBinary(p)
	if errC != nil {
		return errC
	}
	target.end = *n
	// --- [end][read][reference](time.Time) ---

	// --- [begin][read][struct](Window) ---
	q := &Window{}
	r := buff.ReadInt()    // byte array length
	s := buff.ReadBytes(r) // byte array
	errD := q.UnmarshalBinary(s)
	if errD != nil {
		return errD
	}
	target.window = *q
	// --- [end][read][struct](Window) ---

	t := buff.ReadFloat64() // read float64
	target.adjustment = t

	u := buff.ReadString() // read string
	target.NodeType = u

	w := buff.ReadFloat64() // read float64
	target.CPUCoreHours = w

	x := buff.ReadFloat64() // read float64
	target.RAMByteHours = x

	y := buff.ReadFloat64() // read float64
	target.GPUHours = y

	if buff.ReadUInt8() == uint8(0) {
		target.CPUBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		aa := &Breakdown{}
		bb := buff.ReadInt()     // byte array length
		cc := buff.ReadBytes(bb) // byte array
		errE := aa.UnmarshalBinary(cc)
		if errE != nil {
			return errE
		}
		target.CPUBreakdown = aa
		// --- [end][read][struct](Breakdown) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.RAMBreakdown = nil
	} else {
		// --- [begin][read][struct](Breakdown) ---
		dd := &Breakdown{}
		ee := buff.ReadInt()     // byte array length
		ff := buff.ReadBytes(ee) // byte array
		errF := dd.UnmarshalBinary(ff)
		if errF != nil {
			return errF
		}
		target.RAMBreakdown = dd
		// --- [end][read][struct](Breakdown) ---

	}
	gg := buff.ReadFloat64() // read float64
	target.CPUCost = gg

	hh := buff.ReadFloat64() // read float64
	target.GPUCost = hh

	kk := buff.ReadFloat64() // read float64
	target.GPUCount = kk

	ll := buff.ReadFloat64() // read float64
	target.RAMCost = ll

	mm := buff.ReadFloat64() // read float64
	target.Discount = mm

	nn := buff.ReadFloat64() // read float64
	target.Preemptible = nn

	return nil
}

//--------------------------------------------------------------------------
//  PVAllocation
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVAllocation instance
// into a byte array
func (target *PVAllocation) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteFloat64(target.ByteHours) // write float64
	buff.WriteFloat64(target.Cost)      // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVAllocation type
func (target *PVAllocation) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVAllocation. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.ByteHours = a

	b := buff.ReadFloat64() // read float64
	target.Cost = b

	return nil
}

//--------------------------------------------------------------------------
//  PVKey
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this PVKey instance
// into a byte array
func (target *PVKey) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteString(target.Cluster) // write string
	buff.WriteString(target.Name)    // write string
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the PVKey type
func (target *PVKey) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling PVKey. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadString() // read string
	target.Cluster = a

	b := buff.ReadString() // read string
	target.Name = b

	return nil
}

//--------------------------------------------------------------------------
//  RawAllocationOnlyData
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this RawAllocationOnlyData instance
// into a byte array
func (target *RawAllocationOnlyData) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	buff.WriteFloat64(target.CPUCoreUsageMax)  // write float64
	buff.WriteFloat64(target.RAMBytesUsageMax) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the RawAllocationOnlyData type
func (target *RawAllocationOnlyData) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling RawAllocationOnlyData. Expected %d, got %d", CodecVersion, version)
	}

	a := buff.ReadFloat64() // read float64
	target.CPUCoreUsageMax = a

	b := buff.ReadFloat64() // read float64
	target.RAMBytesUsageMax = b

	return nil
}

//--------------------------------------------------------------------------
//  SharedAsset
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this SharedAsset instance
// into a byte array
func (target *SharedAsset) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.properties == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](AssetProperties) ---
		a, errA := target.properties.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][struct](AssetProperties) ---

	}
	// --- [begin][write][alias](AssetLabels) ---
	if map[string]string(target.labels) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(map[string]string(target.labels))) // map length
		for v, z := range map[string]string(target.labels) {
			buff.WriteString(v) // write string
			buff.WriteString(z) // write string
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [end][write][alias](AssetLabels) ---

	// --- [begin][write][struct](Window) ---
	b, errB := target.window.MarshalBinary()
	if errB != nil {
		return nil, errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][struct](Window) ---

	buff.WriteFloat64(target.Cost) // write float64
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the SharedAsset type
func (target *SharedAsset) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling SharedAsset. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.properties = nil
	} else {
		// --- [begin][read][struct](AssetProperties) ---
		a := &AssetProperties{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.properties = a
		// --- [end][read][struct](AssetProperties) ---

	}
	// --- [begin][read][alias](AssetLabels) ---
	var d map[string]string
	if buff.ReadUInt8() == uint8(0) {
		d = nil
	} else {
		// --- [begin][read][map](map[string]string) ---
		f := buff.ReadInt() // map len
		e := make(map[string]string, f)
		for i := 0; i < f; i++ {
			var v string
			g := buff.ReadString() // read string
			v = g

			var z string
			h := buff.ReadString() // read string
			z = h

			e[v] = z
		}
		d = e
		// --- [end][read][map](map[string]string) ---

	}
	target.labels = AssetLabels(d)
	// --- [end][read][alias](AssetLabels) ---

	// --- [begin][read][struct](Window) ---
	k := &Window{}
	l := buff.ReadInt()    // byte array length
	m := buff.ReadBytes(l) // byte array
	errB := k.UnmarshalBinary(m)
	if errB != nil {
		return errB
	}
	target.window = *k
	// --- [end][read][struct](Window) ---

	n := buff.ReadFloat64() // read float64
	target.Cost = n

	return nil
}

//--------------------------------------------------------------------------
//  Window
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Window instance
// into a byte array
func (target *Window) MarshalBinary() (data []byte, err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBuffer()
	buff.WriteUInt8(CodecVersion) // version

	if target.start == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		a, errA := target.start.MarshalBinary()
		if errA != nil {
			return nil, errA
		}
		buff.WriteInt(len(a))
		buff.WriteBytes(a)
		// --- [end][write][reference](time.Time) ---

	}
	if target.end == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][reference](time.Time) ---
		b, errB := target.end.MarshalBinary()
		if errB != nil {
			return nil, errB
		}
		buff.WriteInt(len(b))
		buff.WriteBytes(b)
		// --- [end][write][reference](time.Time) ---

	}
	return buff.Bytes(), nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinary(data []byte) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := util.NewBufferFromBytes(data)

	// Codec Version Check
	version := buff.ReadUInt8()
	if version != CodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Window. Expected %d, got %d", CodecVersion, version)
	}

	if buff.ReadUInt8() == uint8(0) {
		target.start = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.start = a
		// --- [end][read][reference](time.Time) ---

	}
	if buff.ReadUInt8() == uint8(0) {
		target.end = nil
	} else {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.end = d
		// --- [end][read][reference](time.Time) ---

	}
	return nil
}
